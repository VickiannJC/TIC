//BACKGROUND.JS
// ==========================
// CONFIG SERVERS
// ==========================
const SERVER_BASE_URL = "https://undeviously-largest-rashida.ngrok-free.dev";
const POLLING_INTERVAL = 3000;
const MAX_TIMEOUT = 60000;

const leaderFrames = {};


console.log("[SW] Cargado y listo.");

//Listeners para que Chrome no apaguw SW inmediatamente despu√©s de recibir un mensaje
chrome.runtime.onMessageExternal.addListener(() => { });
chrome.runtime.onMessage.addListener(() => { });


//Para que SW controle todas las p√°ginas inmediatamente
self.addEventListener("activate", () => {
    self.clients.claim();
});

// ==========================
// CONTROL DE TABS ACTIVOS
// ==========================
const activeTabs = new Set();
let lastTabId = null; // √∫ltimo tab conocido


// ==========================
// EVENTOS SERVICE WORKER MV3
// ==========================
chrome.runtime.onInstalled.addListener(() => {
    console.log("[SW] Instalado.");
});

chrome.runtime.onStartup.addListener(() => {
    console.log("[SW] Reiniciado.");
});

// ==========================
// GET KEY MATERIAL (LOGIN)
// ==========================
async function getKeyMaterialWithToken(token, email, platform) {
    try {
        const response = await fetch(`${KEY_MANAGER_URL}/get_key_material`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                auth_token: token,
                user_email: email,
                platform_name: platform
            })
        });

        if (!response.ok) {
            throw new Error("Error al solicitar material de clave al Key Manager");
        }

        return await response.json();
    } catch (err) {
        console.error("[SW] Error Key Manager:", err);
        return null;
    }
}

// ==========================
// LOGIN FLOW
// ==========================
async function startAuthFlow(email, platform, tabId) {
    try {
        const resp = await fetch(`${SERVER_BASE_URL}/request-auth-login`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ email, platform })
        });

        if (!resp.ok) {
            if (resp.status === 404) throw new Error("Dispositivo no vinculado");
            throw new Error("Error al iniciar Push Auth");
        }
        const contentType = resp.headers.get("content-type");
        if (!contentType || !contentType.includes("application/json")) {
            throw new Error("Servidor devolvi√≥ HTML/Texto en lugar de JSON");
        }

        await resp.json();
        console.log("[SW] Push de login enviado, iniciando polling‚Ä¶");

        startTokenPolling(email, platform, tabId);

    } catch (err) {
        console.error("[SW] Error en flujo de login:", err);
        sendToLeaderFrame(tabId, {
            action: "authTimeout",
            message: err.message
        });
        sendToLeaderFrame(tabId, {
            action: "resetAuthButtons"
        });

    }
}

// ==========================
// REGISTRO ‚Äì GENERAR QR
// ==========================
async function startRegistrationFlow(email, platform, tabId) {
    try {
        const resp = await fetch(`${SERVER_BASE_URL}/generar-qr-sesion`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ email, platform })
        });

        const contentType = resp.headers.get("content-type") || "";
        if (!contentType.includes("application/json")) {
            const txt = await resp.text();
            throw new Error("Respuesta no JSON: " + txt.substring(0, 200));
        }

        if (!resp.ok) {
            const errData = await resp.json();
            if (resp.status === 409 && errData.error === "email_exists") {
                sendToLeaderFrame(tabId, {
                    action: "emailAlreadyRegistered",
                    message: errData.message
                });
                return;
            }
            throw new Error(errData.error || "Error al generar QR");
        }

        const data = await resp.json();
        const qrData = data.qr;

        console.log(`[SW] QR recibido desde backend para: ${email} en tab ${tabId}`);

        sendToLeaderFrame(tabId, { action: "prepareForQR" });

        setTimeout(() => {
            sendToLeaderFrame(tabId, { action: "showRegistrationQR", qrData, email, platform });
        }, 50);


    } catch (err) {
        console.error("[SW] Error en flujo de registro:", err);

        sendToLeaderFrame(tabId, {
            action: "authTimeout",
            message: err.message
        });
        sendToLeaderFrame(tabId, {
            action: "resetAuthButtons"
        });

    }
}


// ==========================
// LOGIN ‚Äì POLLING
// ==========================
function startTokenPolling(email, platform, tabId) {
    let intervalId = null;
    let timedOut = false;

    const timeoutId = setTimeout(() => {
        timedOut = true;
        if (intervalId !== null) clearInterval(intervalId);
        sendToLeaderFrame(tabId, {
            action: "authTimeout",
            message: "Tiempo de espera agotado (60s)."
        });
        sendToLeaderFrame(tabId, {
            action: "resetAuthButtons"
        });

    }, MAX_TIMEOUT);

    intervalId = setInterval(async () => {
        if (timedOut) return;

        try {
            const resp = await fetch(
                `${SERVER_BASE_URL}/check-password-status?email=${encodeURIComponent(email)}`
            );

            const contentType = resp.headers.get("content-type");
            if (!contentType || !contentType.includes("application/json")) {
                throw new Error("Servidor devolvi√≥ HTML/Texto en lugar de JSON");
            }

            const data = await resp.json();

            if (data.status === "authenticated" && data.token) {
                clearTimeout(timeoutId);
                clearInterval(intervalId);

                const keyMaterial = await getKeyMaterialWithToken(
                    data.token, email, platform
                );

                if (keyMaterial) {
                    sendToLeaderFrame(tabId, {
                        action: "fillKeyMaterial",
                        keyMaterial
                    });
                } else {
                    sendToLeaderFrame(tabId, {
                        action: "authTimeout",
                        message: "Fallo al obtener material de clave."
                    });
                    sendToLeaderFrame(tabId, {
                        action: "resetAuthButtons"
                    });

                }
            } else if (data.status === "denied") {
                clearTimeout(timeoutId);
                clearInterval(intervalId);

                sendToLeaderFrame(tabId, {
                    action: "authTimeout",
                    message: "Autenticaci√≥n rechazada por el usuario."
                });
                sendToLeaderFrame(tabId, {
                    action: "resetAuthButtons"
                });

            }

        } catch (err) {
            console.error("[SW] Error en polling:", err);
            clearTimeout(timeoutId);
            clearInterval(intervalId);

            sendToLeaderFrame(tabId, {
                action: "authTimeout",
                message: "Error de red durante autenticaci√≥n."
            });
            sendToLeaderFrame(tabId, {
                action: "resetAuthButtons"
            });

        }

    }, POLLING_INTERVAL);
}

function sendToLeaderFrame(tabId, payload) {
    const frameId = leaderFrames[tabId];
    if (frameId == null) {
        console.warn("[SW] No existe frame l√≠der para tab", tabId,
            "al intentar enviar action:", payload.action);
        return;
    }

    chrome.tabs.sendMessage(
        tabId,
        payload,
        { frameId },
        () => {

            // --- Reintento autom√°tico (si frame muri√≥) ---
            if (chrome.runtime.lastError &&
                chrome.runtime.lastError.message.includes("message port closed")) {

                console.warn("[SW] FRAME l√≠der muri√≥ ‚Äì solicitando nueva identificaci√≥n‚Ä¶");

                chrome.tabs.sendMessage(tabId, { action: "forceReidentify" });
                return; // detener ejecuci√≥n normal
            }

            // --- Paso 4: Heartbeat para mantener vivo el frame l√≠der ---
            chrome.tabs.sendMessage(tabId, { action: "heartbeat" }, { frameId });

            // Log normal
            if (!chrome.runtime.lastError) {
                console.log("[SW] Mensaje", payload.action,
                    "enviado a tab", tabId, "frame", frameId);
            }
        }
    );
}



// ==========================
// LISTENER PRINCIPAL MV3
// ==========================
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    console.log("üì® BG: Mensaje recibido:", request.action);
    if (request.action === "heartbeat") {
    // No hacemos nada ‚Äî solo servir para mantener vivo el puerto
    return;
}


    // cuando un content script detecta el campo de contrase√±a
    if (request.action === "passwordFieldDetected" && sender.tab) {
        leaderFrames[sender.tab.id] = sender.frameId ?? 0;
        console.log("[SW] Frame l√≠der asignado para tab",
            sender.tab.id, "frameId", sender.frameId);
        // no hace falta sendResponse aqu√≠
        return;
    }

    // ======== Login ========
    if (request.action === "requestAuthLogin") {
        const platformSafe = request.platform?.trim() || "Unknown";

        const realTabId = sender?.tab?.id;
        if (!realTabId) {
            console.warn("[SW] requestAuthLogin sin tabId");
            sendResponse?.({ ok: false, error: "No tabId" });
            return true;
        }

        startAuthFlow(request.email, platformSafe, realTabId);
        return true;
    }


    // ======== Registro ========
    if (request.action === "requestRegistration") {

        const realTabId = request.tabId;
        if (!realTabId) {
            console.warn("[SW] requestRegistration sin tabId");
            sendResponse?.({ ok: false, error: "No tabId" });
            return true;
        }

        const email = request.email;
        const platform = request.platform ?? "Browser";

        console.log("[SW] Procesando requestRegistration en tab:", realTabId);

        // 1) Actualizar contexto solo en el frame l√≠der
        sendToLeaderFrame(realTabId, {
            action: "updateContext",
            email,
            platform,
        });

        sendResponse({ ok: true });

        // 2) Lanzar flujo de registro
        startRegistrationFlow(email, platform, realTabId);
        return true;
    }

});

// ==============================================
// Cuando el Service Worker ser√° suspendido
// ==============================================
chrome.runtime.onSuspend.addListener(() => {
    console.log("[SW] Suspendido ‚Üí limpiando estados antes de dormir‚Ä¶");

    // Limpieza opcional de variables globales del SW
    activeSession = null;
    currentEmail = null;
    currentPlatform = null;

    // Cancelar timers si usas alguno (por seguridad)
    if (globalThis._psyTimeout) {
        clearTimeout(globalThis._psyTimeout);
        globalThis._psyTimeout = null;
    }

    // Si dejaste alg√∫n intervalo dentro del SW (solo en ese caso)
    if (globalThis._psyInterval) {
        clearInterval(globalThis._psyInterval);
        globalThis._psyInterval = null;
    }

    // Puedes agregar logs o limpiar cach√©s aqu√≠ si lo deseas
    console.log("[SW] Estado limpio. El Service Worker puede dormirse.");
});



