2. Flujo del TOKEN en el LOGIN

Cuando el usuario hace clic en ‚ÄúInicio de sesi√≥n‚Äù:

1Ô∏è‚É£ El backend recibe /request-auth-login

y genera un challengeId + un documento Temporal:

await Temporal.create({
    email,
    challengeId,
    status: "pending"
});

2Ô∏è‚É£ Se env√≠a un PUSH al dispositivo

con:

actionType: "auth",
sessionId: challengeId

3Ô∏è‚É£ El usuario confirma en el m√≥vil

‚Üí /auth-confirm cambia:

status: "pending" ‚Üí "confirmed"
token = generateToken();


Ese token es lo que prueba que:

‚û° El m√≥vil recibi√≥ la solicitud
‚û° El usuario toc√≥ ‚ÄúAceptar‚Äù
‚û° La identidad est√° verificada

4Ô∏è‚É£ El Service Worker hace polling y recibe:
{ status: "authenticated", token: "ABC123..." }

5Ô∏è‚É£ El SW llama al Key Manager:
getKeyMaterialWithToken(token, email, platform)


Y el Key Manager devuelve la clave derivada para desencriptar la contrase√±a.

üëâ Sin token, NO hay clave.
Sin clave, NO hay login.

üü© 3. Flujo del TOKEN en el REGISTRO

En registro es similar, pero el token est√° impl√≠cito en el ‚Äúconfirmado‚Äù.

1Ô∏è‚É£ Se genera QR con sessionId
2Ô∏è‚É£ El m√≥vil llama a /register-mobile

con la suscripci√≥n push temporal

3Ô∏è‚É£ Se env√≠a un PUSH al m√≥vil
4Ô∏è‚É£ El usuario confirma la vinculaci√≥n
5Ô∏è‚É£ /register-confirm valida status=confirmed

y ah√≠ el registro se vuelve definitivo:

Subscripcion.findOneAndUpdate(...)


üëâ En registro el token es el "confirmed" del flujo push,
no un token final como en login.

Pero cumple el MISMO prop√≥sito:

‚û° Garantiza que la confirmaci√≥n viene del m√≥vil real
‚û° Impide registros falsos
‚û° Impide secuestros desde otra pesta√±a
‚û° Impide registrar sin QR v√°lido

A. Token de REGISTRO (impl√≠cito)

No lo ves directo.

Proviene de /register-confirm.

Solo valida que un m√≥vil confirm√≥ el registro.

No sirve para biometr√≠a.

üîπ B. Token de LOGIN (challenge token)


Tres TOKENS en la extensi√≥n, uno para registro, otro para login y otro para conexi√≥n con biometr√≠a

TOKEN BIometria: Ese token biom√©trico debe:

tener TTL corto

ser de un solo uso

no permitir acceso a KeyManager

estar asociado al correo

ser destruido al usarlo